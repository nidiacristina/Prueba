function particles = smpm_track_particles( data, x, z, dt )
% particles = smpm_track_particles( data, x, z, dt )
%
% NOTE: This only works for cartesian meshes (e.g. those generated by
%       smpm_build_cartesian_mesh()).
%
% Takes 4 input arguments:
%
%   data - Field data structure returned by smpm_read_fieldfile().
%   x    - Column vector representing particles' initial x locations.
%   z    - Column vector representing particles' initial z locations.
%   dt   - Time step between consecutive times in data.
%
% Returns 1 value:
%
%  particles  - Structure containing the following fields:
%
%          .x - Matrix representing the x-positions of the particles,
%               with the number of rows equal to the number of particles,
%               and the number of columns equal to the number of time-steps
%               in data.
%          .z - matrix representing the z-positions of the particles,
%               with the number of rows equal to the number of particles,
%               and the number of columns equal to the number of time-steps
%               in data.
%

% Make sure the input particle position arrays are column vectors.
if size( x, 1 ) < size( x, 2 )
    x = x';
end
if size( z, 1 ) < size( z, 2 )
    z = z';
end

% Set some constants.
ntime = size( data.field.ux, 3 );
npart = length(x);
r     = data.grid.n * data.grid.n * data.grid.mx * data.grid.mz;

% Find the bounding box of the domain.
xdomain(1) = min( data.grid.x(:) );
xdomain(2) = max( data.grid.x(:) );
zdomain(1) = min( data.grid.z(:) );
zdomain(2) = max( data.grid.z(:) );

% Allocate arrays.
particles.x = zeros( npart, ntime );
particles.z = zeros( npart, ntime );

% Set the initial conditions.
particles.x(:, 1) = x;
particles.z(:, 1) = z;

% Loop over time-steps, constructing interpolants and integrating.
for ii = 2:ntime

    fprintf( 'Time step %d of %d\n', ii, ntime );

    % Use spectral interpolation to get the velocities at the particle positions.
    ux_p = smpm_spectral_interp( data.grid, data.field.ux(:, :, ii - 1), particles.x(:, ii - 1), particles.z(:, ii - 1) );
    uz_p = smpm_spectral_interp( data.grid, data.field.uz(:, :, ii - 1), particles.x(:, ii - 1), particles.z(:, ii - 1) );

    % Integrate to the next time-step.
    particles.x(:, ii) = particles.x(:, ii - 1) + dt * ux_p;
    particles.z(:, ii) = particles.z(:, ii - 1) + dt * uz_p;

    % If any particles are outside of the boundaries, put them on the boundary.
    particles.x(particles.x(:, ii) < xdomain(1), ii) = xdomain(1);
    particles.x(particles.x(:, ii) > xdomain(2), ii) = xdomain(2);
    particles.z(particles.z(:, ii) < zdomain(1), ii) = zdomain(1);
    particles.z(particles.z(:, ii) > zdomain(2), ii) = zdomain(2);

end
