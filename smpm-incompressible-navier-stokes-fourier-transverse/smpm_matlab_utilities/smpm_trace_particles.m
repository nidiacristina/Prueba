function pdata = smpm_trace_particles( field_init_name, field_field_name, xpo, zpo, delt )
% pdata = smpm_trace_particles( field file, xpo, zpo, delt )
%
% Reads the contents of field file generated by the SMPM solver in .h5 format
% and uses the smpm_read_fieldfile.m to obtain the particle position based on
% a specified range only. The interpolation takes place via a unique
% non-monotonically increasing grid of dimension (mz*n) x (mx*n).
%
% Takes 4 arguments:
%
%   field_init_name - String indicating the initial conditions file to read from
%                     disk.
%   field_file_name - String indicating the field file to read from disk.
%   xpo             - Column vector, of length n^2 * mx * mz x 1, containing
%                     the x coordinates of the original particle positions.
%   zpo             - Column vector, of length n^2 * mx * mz x 1, containing
%                     the z coordinates of the original particle positions.
%   dt              - Data sampling time step as specified in the SMPM Code.
%
% Returns 1 value:
%
%   pdata - Structure with fields as described below:
%
%     .grid.x          - Matrix, of size (mz*n) x (mx*n) x num_steps, containing
%                        the x-coordinates of the non-monotonically increasing
%                        grid.
%     .grid.z          - Matrix, of size (mz*n) x (mx*n) x num_steps, containing
%                        the z-coordinates of the non-monotonically increasing
%                        grid.
%     .field.xp        - Matrix, of size (mz*n) x (mx*n) x num_steps, containing
%                        the x-coordinates of the particles
%     .field.zp        - Matrix, of size (mz*n) x (mx*n) x num_steps, containing
%                        the z-coordinates of the particles
%     .field.ux_n      - Matrix, of size (mz*n) x (mx*n) x num_steps, containing
%                        the horizontal wave-induced velocity field for all time.
%     .field.uz_n      - Matrix, of size (mz*n) x (mx*n) x num_steps, containing
%                        the vertical wave-induced velocity field for all times.
%     .field.rho_n     - Matrix, of size (mz*n) x (mx*n) x num_steps, containing
%                        the wave-induced perturbation density field for all
%                        times.
%     .field.rho_bar_n - Matrix, of size (mz*n) x (mx*n) x num_steps,
%                        containing the wave-induced perturbation density
%                        field for all times.
%

% 29 Jan 2016
% Gustavo Rivera & Sumedh Joshi

%% Load Field Data

% Load the initial conditions and field data.
init = smpm_read_initfile( field_init_name );
data = smpm_read_fieldfile( field_field_name );

% Obtain the grid dimension and number of timesteps.
[Nz, Nx, tend] = size( data.field.rho );

% Shorten the variable names we're working with.
x = data.grid.x;
z = data.grid.z;

%% Eliminate Non-Monotonic Grid

% Identify the unique grid values.
[CX, IAX, ICX] = unique( x(end, :) );
[CZ, IAZ, ICZ] = unique( z(:, end) );

% Obtain new number of points in both X and Z.
Nzn = length( IAZ );
Nxn = length( IAX );

% Allocate the new matrices.
ux_n      = zeros( length( IAZ ), length( IAX ) );
uz_n      = zeros( length( IAZ ), length( IAX ) );
rho_n     = zeros( length( IAZ ), length( IAX ) );
rho_bar_n = zeros( length( IAZ ), length( IAX ) );

% Create particle position matrices from our multiplexed vectors.
xpd = reshape( xpo, Nz, Nx );
zpd = reshape( zpo, Nz, Nx );

% Initialize Particle Location Arrays
xp = zeros( Nzn, Nxn, tend );
zp = zeros( Nzn, Nxn, tend );

% Obtain data at non-monotonically increasing grid at all times
for m = 1:tend
    for i = 1:length( IAX )
        for k = 1:length( IAZ )
            ux_n(k, i, m)  = data.field.ux(IAZ(k), IAX(i), m);
            uz_n(k, i, m)  = data.field.uz(IAZ(k), IAX(i), m);
            rho_n(k ,i, m) = data.field.rho(IAZ(k), IAX(i), m);
            xp(k, i, m)    = xpd(IAZ(k), IAX(i));
            zp(k, i, m)    = zpd(IAZ(k), IAX(i));
        end
    end
end

% Obtain background density at non-monotonically increasing grid
for i = 1:length(IAX)
    for k = 1:length(IAZ)
        rho_bar_n(k, i) = init.ic.rho_bar(IAZ(k), IAX(i));
    end
end

% Construct non-monotonically increasing grid
[x_n, z_n] = meshgrid( CX, CZ );

%% Particle Displacement Computation

% Begin Main Particle Interpolation Loop
for t = 2:2

    % Grab data at previous timestep.
    dummyux = ux_n(:, :, t-1);
    dummyuz = uz_n(:, :, t-1);
    dummyxp = xp(:, :, t-1);
    dummyzp = zp(:, :, t-1);

    % Clamp out of bound particles to the x-domain's boundaries.
    B          = dummyxp > max( max( x_n ) );
    dummyxp(B) = max( max( x_n ) );
    B          = dummyxp < min( min( x_n ) );
    dummyxp(B) = min( min( x_n ) );

    % Clamp out of bound particles to the z-domain's boundaries.
    B          = dummyzp > max( max( z_n ) );
    dummyzp(B) = max( max( z_n ) );
    B          = dummyzp < min( min( z_n ) );
    dummyzp(B) = min( min( z_n ) );

    % Build the interpolating functions in x and z.
    uxint = scatteredInterpolant( x_n(:), z_n(:), dummyux(:), 'natural' );
    uzint = scatteredInterpolant( x_n(:), z_n(:), dummyuz(:), 'natural' );
    ux_d  = uxint(dummyxp(:), dummyzp(:));
    uz_d  = uzint(dummyxp(:), dummyzp(:));

    % Reshape arrays to add with previous location.
    ux_d = reshape( ux_d, Nzn, Nxn );
    uz_d = reshape( uz_d, Nzn, Nxn );

    % Compute the new particle position.
    xp(:, :, t) = xp(:, :, t-1) + delt.*ux_d;
    zp(:, :, t) = zp(:, :, t-1) + delt.*uz_d;

    % Re-initialize variables for next time step.
    clear dummyux dummyuz dummyxp dummyzp ux_d uz_d uxint uzint B

end

%% Data Output

% Store the grid.
pdata.grid.x_n = x_n;
pdata.grid.z_n = z_n;

% Store the particle positions.
pdata.field.xp = xp;
pdata.field.zp = zp;

% Store the field variables.
pdata.field.ux_n      = ux_n;
pdata.field.uz_n      = uz_n;
pdata.field.rho_n     = rho_n;
pdata.field.rho_bar_n = rho_bar_n;
