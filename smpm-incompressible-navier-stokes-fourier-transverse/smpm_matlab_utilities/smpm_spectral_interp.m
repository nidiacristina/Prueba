function qi = smpm_spectral_interp( grid, q, xi, zi );
% qi = smpm_spectral_interp( grid, q, xi, zi );
%
% Computes a spectral interpolant.
%
% NOTE: only works for meshes generated by smpm_build_cartesian_mesh().
%
% Takes 4 input arguments:
%
%   grid   - Grid structure as returned by smpm_read_initfile().
%   q      - Grid function defined on the grid.
%   xi     - x-coordinates on which to interpolate q.
%   zi     - z-coordinates on which to interpolate q.
%
% Returns 1 value:
%
%   qi     - interpolated value of q on xi, zi.
%

% Make sure the input particle position arrays are column vectors.
if size( xi, 1 ) < size( xi, 2 )
    xi = xi';
end
if size( zi, 1 ) < size( zi, 2 )
    zi = zi';
end

% Set some constants.
nint  = length( xi );
mx    = grid.mx;
mz    = grid.mz;
n     = grid.n;
r     = grid.n * grid.n * grid.mx * grid.mz;
xlim  = [min( grid.x(:) ) max( grid.x(:) )];
zlim  = [min( grid.z(:) ) max( grid.z(:) )];
hx    = (xlim(2) - xlim(1)) / grid.mx;
hz    = (zlim(2) - zlim(1)) / grid.mz;

% Create an array of element boundary points.
x_ebp = linspace( xlim(1), xlim(2), mx + 1 );
z_ebp = linspace( zlim(1), zlim(2), mz + 1 );

% Out of bounds interpolation points are set to NaN.
xi(xi < xlim(1)) = NaN;
xi(xi > xlim(2)) = NaN;
zi(zi < zlim(1)) = NaN;
zi(zi > zlim(2)) = NaN;

% Figure out the element indices each interpolation point is in.
for ii = 1:nint
    ndx_x(ii) = min( find( xi(ii) >= x_ebp, 1, 'last' ), mx ); %
    ndx_z(ii) = min( find( zi(ii) >= z_ebp, 1, 'last' ), mz ); % The min's are there to take care of the edge case.
end

% Loop over elements, computing the interpolation for all points within that element.
qi = 0 * xi;
for eltx = 1:mx
    for eltz = 1:mz

        % Get all interpolation points within this element.
        points_in_this_element = find( ndx_x == eltx & ndx_z == eltz );

        % If there are any points, do interpolation, otherwise move on.
        if length( points_in_this_element ) == 0
            continue;
        end

        % Grab the points in this element.
        iix = xi(points_in_this_element);
        iiz = zi(points_in_this_element);

        % Grab the GLL grid within this element.
        ax = (eltx - 1) * n + 1;
        bx = (eltx - 1) * n + n;
        xe = grid.x(1, ax:bx);

        az = (eltz - 1) * n + 1;
        bz = (eltz - 1) * n + n;
        ze = grid.z(az:bz, 1);

        qe = q(az:bz, ax:bx);

        % Compute the 2D Lagrange interpolation.
        iiq = smpm_lagrange_interp_2D( xe, ze, qe, iix, iiz );

        % Put these back in the output array qi.
        qi(points_in_this_element) = iiq;

    end
end
